/**
 * MKV Subtitle Extractor - Interface para extra√ß√£o de legendas
 */

class MKVExtractorUI {
    constructor() {
        this.tracks = [];
        this.selectedTracks = new Set();
        this.currentMkvFile = null;

        this.initializeElements();
        this.setupEventListeners();
    }

    initializeElements() {
        // File input
        this.fileInput = document.getElementById('srtFile'); // Usar o input principal
        this.fileNameDisplay = document.getElementById('mkvFileName');

        // Tracks list
        this.tracksContainer = document.getElementById('subtitleTracksList');
        this.tracksCard = document.getElementById('subtitleTracksCard');

        // Buttons
        this.analyzeBtn = document.getElementById('analyzeMkvBtn');
        this.extractBtn = document.getElementById('extractSubtitlesBtn');
        this.selectAllBtn = document.getElementById('selectAllTracksBtn');
        this.deselectAllBtn = document.getElementById('deselectAllTracksBtn');

        // Progress
        this.extractProgress = document.getElementById('extractionProgress');
        this.extractedList = document.getElementById('extractedSubtitlesList');

        console.log('üîß MKV Extractor elementos inicializados');
    }

    setupEventListeners() {
        // Analyze button
        if (this.analyzeBtn) {
            this.analyzeBtn.addEventListener('click', () => this.analyzeMkvFile());
            console.log('‚úÖ Analyze button listener attached');
        }

        // Extract button
        if (this.extractBtn) {
            this.extractBtn.addEventListener('click', () => this.extractSelectedTracks());
        }

        // Select/Deselect all
        if (this.selectAllBtn) {
            this.selectAllBtn.addEventListener('click', () => this.selectAllTracks());
        }

        if (this.deselectAllBtn) {
            this.deselectAllBtn.addEventListener('click', () => this.deselectAllTracks());
        }
    }


    async analyzeMkvFile() {
        if (!this.currentMkvFile) {
            alert('Por favor selecione um ficheiro MKV primeiro!');
            return;
        }

        console.log('üîç Analisando ficheiro MKV...');

        try {
            // Criar FormData para enviar ficheiro
            const formData = new FormData();
            formData.append('mkv_file', this.currentMkvFile);

            // Chamar backend para analisar
            const response = await fetch('http://localhost:8080/api/mkv/analyze', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error(`Erro HTTP: ${response.status}`);
            }

            const result = await response.json();
            console.log('üì¶ Tracks recebidas:', result);

            if (result.tracks && result.tracks.length > 0) {
                this.tracks = result.tracks;
                this.renderTracks();
            } else {
                alert('Nenhuma track de legendas encontrada neste ficheiro!');
            }

        } catch (error) {
            console.error('‚ùå Erro ao analisar MKV:', error);
            alert(`Erro ao analisar ficheiro: ${error.message}`);
        }
    }

    renderTracks() {
        console.log('üé® Renderizando tracks de legendas...');

        this.tracksContainer.innerHTML = '';
        this.selectedTracks.clear();

        if (this.tracks.length === 0) {
            this.tracksCard.classList.add('hidden');
            return;
        }

        this.tracksCard.classList.remove('hidden');

        // Criar item para cada track
        this.tracks.forEach(track => {
            const trackItem = this.createTrackItem(track);
            this.tracksContainer.appendChild(trackItem);

            // Selecionar por defeito se for a track padr√£o
            if (track.is_default) {
                this.selectedTracks.add(track.id);
                trackItem.querySelector('input[type="checkbox"]').checked = true;
            }
        });

        // Atualizar contador
        this.updateSelectionCount();
    }

    createTrackItem(track) {
        const item = document.createElement('div');
        item.className = 'track-item';

        // Detectar idioma usando o sistema centralizado
        const langDisplay = window.languageDetector.getLanguageDisplay(track);
        const flagEmoji = langDisplay.flag;
        const languageName = langDisplay.name;

        // Default marker
        const defaultMarker = track.is_default ? '<span class="default-badge">Padr√£o</span>' : '';

        // Forced marker (para legendas obrigat√≥rias, ex: sinais, alien text, etc)
        const forcedMarker = track.name && track.name.toLowerCase().includes('forced')
            ? '<span class="forced-badge">For√ßada</span>' : '';

        // SDH/CC marker (para legendas para surdos)
        const sdhMarker = track.name && (
            track.name.toLowerCase().includes('sdh') ||
            track.name.toLowerCase().includes('cc') ||
            track.name.toLowerCase().includes('deaf')
        ) ? '<span class="sdh-badge">SDH</span>' : '';

        item.innerHTML = `
            <label class="track-label">
                <input type="checkbox"
                       data-track-id="${track.id}"
                       class="track-checkbox">
                <div class="track-info">
                    <div class="track-header">
                        <span class="track-language">${flagEmoji} ${languageName}</span>
                        <span class="track-codec">${track.codec}</span>
                        ${defaultMarker}
                        ${forcedMarker}
                        ${sdhMarker}
                    </div>
                    ${track.name ? `<div class="track-name">${track.name}</div>` : ''}
                    <div class="track-id">Track ID: ${track.id}</div>
                </div>
            </label>
        `;

        // Listener para checkbox
        const checkbox = item.querySelector('input[type="checkbox"]');
        checkbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                this.selectedTracks.add(track.id);
            } else {
                this.selectedTracks.delete(track.id);
            }
            this.updateSelectionCount();
        });

        return item;
    }

    /**
     * Detecta idioma e variante a partir do c√≥digo (suporta ISO 639-1, 639-2 e 639-3)
     * e informa√ß√µes do nome da track
     */
    detectLanguageInfo(track) {
        const langCode = (track.language || 'und').toLowerCase();
        const trackName = (track.name || '').toLowerCase();

        // Normalizar c√≥digo de idioma (converter para c√≥digo de 3 letras padr√£o)
        const normalizedCode = this.normalizeLanguageCode(langCode);

        // Detectar variante lingu√≠stica pelo nome da track
        let variant = null;

        // Portugu√™s: PT-PT vs PT-BR
        if (normalizedCode === 'por') {
            if (trackName.includes('brazil') || trackName.includes('brazilian') ||
                trackName.includes('brasil') || trackName.includes('pt-br') || trackName.includes('ptbr')) {
                variant = 'BR';
            } else if (trackName.includes('portugal') || trackName.includes('european') ||
                       trackName.includes('pt-pt') || trackName.includes('ptpt')) {
                variant = 'PT';
            }
            // Se n√£o especificado, assumir PT-PT (mais comum em web-dl europeus)
        }

        // Ingl√™s: US vs UK
        if (normalizedCode === 'eng') {
            if (trackName.includes('us') || trackName.includes('american')) {
                variant = 'US';
            } else if (trackName.includes('uk') || trackName.includes('british')) {
                variant = 'GB';
            }
        }

        // Espanhol: ES vs LATAM
        if (normalizedCode === 'spa') {
            if (trackName.includes('latin') || trackName.includes('latam') ||
                trackName.includes('latino') || trackName.includes('mx')) {
                variant = 'LATAM';
            } else if (trackName.includes('spain') || trackName.includes('castellano') ||
                       trackName.includes('espa√±a')) {
                variant = 'ES';
            }
        }

        // Franc√™s: FR vs CA (Canad√°)
        if (normalizedCode === 'fra') {
            if (trackName.includes('canada') || trackName.includes('canadian') ||
                trackName.includes('qu√©bec') || trackName.includes('quebec')) {
                variant = 'CA';
            }
        }

        // Chin√™s: Simplificado vs Tradicional
        if (normalizedCode === 'chi' || normalizedCode === 'zho') {
            if (trackName.includes('traditional') || trackName.includes('hant') ||
                trackName.includes('tw') || trackName.includes('hk')) {
                variant = 'TRAD';
            } else if (trackName.includes('simplified') || trackName.includes('hans') ||
                       trackName.includes('cn')) {
                variant = 'SIMP';
            }
        }

        return { code: normalizedCode, variant: variant };
    }

    /**
     * Normaliza c√≥digos de idioma para formato padr√£o de 3 letras (ISO 639-2)
     */
    normalizeLanguageCode(code) {
        const normalized = code.toLowerCase();

        // Mapa completo de c√≥digos de 2 letras (ISO 639-1) para 3 letras (ISO 639-2/T)
        const iso2to3 = {
            // Principais idiomas
            'en': 'eng', 'pt': 'por', 'es': 'spa', 'fr': 'fra', 'de': 'ger',
            'it': 'ita', 'ja': 'jpn', 'zh': 'chi', 'ko': 'kor', 'ru': 'rus',

            // Europa Ocidental
            'nl': 'dut', 'sv': 'swe', 'no': 'nor', 'da': 'dan', 'fi': 'fin',
            'is': 'ice', 'ga': 'gle', 'cy': 'wel', 'gd': 'gla',

            // Europa Central e Oriental
            'pl': 'pol', 'cs': 'cze', 'sk': 'slo', 'hu': 'hun', 'ro': 'rum',
            'bg': 'bul', 'hr': 'hrv', 'sr': 'srp', 'sl': 'slv', 'mk': 'mac',
            'sq': 'alb', 'lt': 'lit', 'lv': 'lav', 'et': 'est',

            // Europa do Sul
            'el': 'gre', 'tr': 'tur', 'mt': 'mlt',

            // Ex-URSS
            'uk': 'ukr', 'be': 'bel', 'kk': 'kaz', 'uz': 'uzb', 'az': 'aze',
            'hy': 'arm', 'ka': 'geo', 'ky': 'kir', 'tg': 'tgk', 'tk': 'tuk',

            // M√©dio Oriente
            'ar': 'ara', 'he': 'heb', 'fa': 'per', 'ur': 'urd', 'ku': 'kur',

            // √Åsia do Sul
            'hi': 'hin', 'bn': 'ben', 'pa': 'pan', 'ta': 'tam', 'te': 'tel',
            'ml': 'mal', 'mr': 'mar', 'gu': 'guj', 'kn': 'kan', 'si': 'sin',
            'ne': 'nep',

            // Sudeste Asi√°tico
            'th': 'tha', 'vi': 'vie', 'id': 'ind', 'ms': 'may', 'tl': 'tgl',
            'my': 'bur', 'km': 'khm', 'lo': 'lao',

            // Leste Asi√°tico
            'mn': 'mon',

            // √Åfrica
            'sw': 'swa', 'am': 'amh', 'ha': 'hau', 'yo': 'yor', 'ig': 'ibo',
            'zu': 'zul', 'xh': 'xho', 'af': 'afr', 'so': 'som',

            // L√≠nguas constru√≠das
            'eo': 'epo',

            // Outros
            'ca': 'cat', 'eu': 'baq', 'gl': 'glg'
        };

        // Mapa de varia√ß√µes alternativas de c√≥digos de 3 letras (ISO 639-2/B para ISO 639-2/T)
        const iso3variants = {
            'deu': 'ger', 'nld': 'dut', 'fra': 'fre', 'zho': 'chi',
            'ces': 'cze', 'slk': 'slo', 'ron': 'rum', 'isl': 'ice',
            'ell': 'gre', 'sqi': 'alb', 'hye': 'arm', 'eus': 'baq',
            'mya': 'bur', 'kat': 'geo', 'mkd': 'mac', 'msa': 'may',
            'fas': 'per', 'bod': 'tib', 'cym': 'wel'
        };

        // Se for c√≥digo de 2 letras, converter
        if (normalized.length === 2 && iso2to3[normalized]) {
            return iso2to3[normalized];
        }

        // Se for variante alternativa de 3 letras, normalizar
        if (normalized.length === 3 && iso3variants[normalized]) {
            return iso3variants[normalized];
        }

        // Se j√° for de 3 letras v√°lido, retornar
        return normalized;
    }

    /**
     * Retorna emoji de bandeira baseado no idioma e variante
     */
    getLanguageFlag(langCode, track = null) {
        // Detectar variante se track fornecida
        let variant = null;
        if (track) {
            const info = this.detectLanguageInfo(track);
            langCode = info.code;
            variant = info.variant;
        }

        const code = this.normalizeLanguageCode(langCode);

        // Bandeiras base por idioma (organizadas por regi√£o)
        const flags = {
            // Principais idiomas (com c√≥digos alternativos)
            'eng': variant === 'US' ? 'üá∫üá∏' : 'üá¨üáß',
            'por': variant === 'BR' ? 'üáßüá∑' : 'üáµüáπ',
            'spa': variant === 'LATAM' ? 'üá≤üáΩ' : 'üá™üá∏',
            'fra': variant === 'CA' ? 'üá®üá¶' : 'üá´üá∑',
            'fre': variant === 'CA' ? 'üá®üá¶' : 'üá´üá∑', // ISO 639-2/B
            'ger': 'üá©üá™',
            'deu': 'üá©üá™', // ISO 639-2/T
            'ita': 'üáÆüáπ',
            'jpn': 'üáØüáµ',
            'chi': variant === 'TRAD' ? 'üáπüáº' : 'üá®üá≥',
            'zho': variant === 'TRAD' ? 'üáπüáº' : 'üá®üá≥',
            'kor': 'üá∞üá∑',
            'rus': 'üá∑üá∫',

            // Europa Ocidental (com c√≥digos alternativos)
            'dut': 'üá≥üá±', 'nld': 'üá≥üá±', // Holand√™s
            'swe': 'üá∏üá™', 'nor': 'üá≥üá¥', 'dan': 'üá©üá∞',
            'fin': 'üá´üáÆ',
            'ice': 'üáÆüá∏', 'isl': 'üáÆüá∏', // Island√™s
            'gle': 'üáÆüá™',
            'wel': 'üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø', 'cym': 'üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø', // Gal√™s
            'gla': 'üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø',

            // Europa Central e Oriental (com c√≥digos alternativos)
            'pol': 'üáµüá±',
            'cze': 'üá®üáø', 'ces': 'üá®üáø', // Checo
            'slo': 'üá∏üá∞', 'slk': 'üá∏üá∞', // Eslovaco
            'hun': 'üá≠üá∫',
            'rum': 'üá∑üá¥', 'ron': 'üá∑üá¥', // Romeno
            'bul': 'üáßüá¨', 'hrv': 'üá≠üá∑', 'srp': 'üá∑üá∏',
            'slv': 'üá∏üáÆ',
            'mac': 'üá≤üá∞', 'mkd': 'üá≤üá∞', // Maced√≥nio
            'alb': 'üá¶üá±', 'sqi': 'üá¶üá±', // Alban√™s
            'lit': 'üá±üáπ', 'lav': 'üá±üáª', 'est': 'üá™üá™',

            // Europa do Sul (com c√≥digos alternativos)
            'gre': 'üá¨üá∑', 'ell': 'üá¨üá∑', // Grego
            'tur': 'üáπüá∑', 'mlt': 'üá≤üáπ',

            // Ex-URSS (com c√≥digos alternativos)
            'ukr': 'üá∫üá¶', 'bel': 'üáßüáæ', 'kaz': 'üá∞üáø', 'uzb': 'üá∫üáø',
            'aze': 'üá¶üáø',
            'arm': 'üá¶üá≤', 'hye': 'üá¶üá≤', // Arm√©nio
            'geo': 'üá¨üá™', 'kat': 'üá¨üá™', // Georgiano
            'kir': 'üá∞üá¨', 'tgk': 'üáπüáØ', 'tuk': 'üáπüá≤',

            // M√©dio Oriente (com c√≥digos alternativos)
            'ara': 'üá∏üá¶', 'heb': 'üáÆüá±',
            'per': 'üáÆüá∑', 'fas': 'üáÆüá∑', // Persa
            'urd': 'üáµüá∞', 'kur': 'üáÆüá∂',

            // √Åsia do Sul
            'hin': 'üáÆüá≥', 'ben': 'üáßüá©', 'pan': 'üáÆüá≥', 'tam': 'üáÆüá≥',
            'tel': 'üáÆüá≥', 'mal': 'üáÆüá≥', 'mar': 'üáÆüá≥', 'guj': 'üáÆüá≥',
            'kan': 'üáÆüá≥', 'sin': 'üá±üá∞', 'nep': 'üá≥üáµ',

            // Sudeste Asi√°tico (com c√≥digos alternativos)
            'tha': 'üáπüá≠', 'vie': 'üáªüá≥', 'ind': 'üáÆüá©',
            'may': 'üá≤üáæ', 'msa': 'üá≤üáæ', // Malaio
            'tgl': 'üáµüá≠',
            'bur': 'üá≤üá≤', 'mya': 'üá≤üá≤', // Birman√™s
            'khm': 'üá∞üá≠', 'lao': 'üá±üá¶',

            // Leste Asi√°tico
            'mon': 'üá≤üá≥',

            // √Åfrica
            'swa': 'üá∞üá™', 'amh': 'üá™üáπ', 'hau': 'üá≥üá¨', 'yor': 'üá≥üá¨',
            'ibo': 'üá≥üá¨', 'zul': 'üáøüá¶', 'xho': 'üáøüá¶', 'afr': 'üáøüá¶',
            'som': 'üá∏üá¥',

            // L√≠nguas constru√≠das
            'epo': 'üåç',

            // Outros (com c√≥digos alternativos)
            'cat': 'üá™üá∏',
            'baq': 'üá™üá∏', 'eus': 'üá™üá∏', // Basco
            'glg': 'üá™üá∏',

            // Desconhecido
            'und': '‚ùì'
        };

        return flags[code] || 'üè≥Ô∏è';
    }

    /**
     * Retorna nome do idioma em portugu√™s com variante
     */
    getLanguageName(langCode, track = null) {
        // Detectar variante se track fornecida
        let variant = null;
        if (track) {
            const info = this.detectLanguageInfo(track);
            langCode = info.code;
            variant = info.variant;
        }

        const code = this.normalizeLanguageCode(langCode);

        const names = {
            // Principais idiomas (com c√≥digos alternativos)
            'eng': 'Ingl√™s',
            'por': 'Portugu√™s',
            'spa': 'Espanhol',
            'fra': 'Franc√™s',
            'fre': 'Franc√™s', // ISO 639-2/B
            'ger': 'Alem√£o',
            'deu': 'Alem√£o', // ISO 639-2/T
            'ita': 'Italiano',
            'jpn': 'Japon√™s',
            'chi': 'Chin√™s',
            'zho': 'Chin√™s',
            'kor': 'Coreano',
            'rus': 'Russo',

            // Europa Ocidental (com c√≥digos alternativos)
            'dut': 'Holand√™s',
            'nld': 'Holand√™s',
            'swe': 'Sueco',
            'nor': 'Noruegu√™s',
            'dan': 'Dinamarqu√™s',
            'fin': 'Finland√™s',
            'ice': 'Island√™s',
            'isl': 'Island√™s',
            'gle': 'Irland√™s',
            'wel': 'Gal√™s',
            'cym': 'Gal√™s',
            'gla': 'Ga√©lico Escoc√™s',

            // Europa Central e Oriental (com c√≥digos alternativos)
            'pol': 'Polaco',
            'cze': 'Checo',
            'ces': 'Checo',
            'slo': 'Eslovaco',
            'slk': 'Eslovaco',
            'hun': 'H√∫ngaro',
            'rum': 'Romeno',
            'ron': 'Romeno',
            'bul': 'B√∫lgaro',
            'hrv': 'Croata',
            'srp': 'S√©rvio',
            'slv': 'Esloveno',
            'mac': 'Maced√≥nio',
            'mkd': 'Maced√≥nio',
            'alb': 'Alban√™s',
            'sqi': 'Alban√™s',
            'lit': 'Lituano',
            'lav': 'Let√£o',
            'est': 'Estoniano',

            // Europa do Sul (com c√≥digos alternativos)
            'gre': 'Grego',
            'ell': 'Grego',
            'tur': 'Turco',
            'mlt': 'Malt√™s',

            // Ex-URSS (com c√≥digos alternativos)
            'ukr': 'Ucraniano',
            'bel': 'Bielorrusso',
            'kaz': 'Cazaque',
            'uzb': 'Uzbeque',
            'aze': 'Azeri',
            'arm': 'Arm√©nio',
            'hye': 'Arm√©nio',
            'geo': 'Georgiano',
            'kat': 'Georgiano',
            'kir': 'Quirguiz',
            'tgk': 'Tajique',
            'tuk': 'Turcomano',

            // M√©dio Oriente (com c√≥digos alternativos)
            'ara': '√Årabe',
            'heb': 'Hebraico',
            'per': 'Persa',
            'fas': 'Persa',
            'urd': 'Urdu',
            'kur': 'Curdo',

            // √Åsia do Sul
            'hin': 'Hindi',
            'ben': 'Bengali',
            'pan': 'Punjabi',
            'tam': 'T√¢mil',
            'tel': 'Telugu',
            'mal': 'Malaiala',
            'mar': 'Marata',
            'guj': 'Guzerate',
            'kan': 'Canar√™s',
            'sin': 'Cingal√™s',
            'nep': 'Nepal√™s',

            // Sudeste Asi√°tico
            'tha': 'Tailand√™s',
            'vie': 'Vietnamita',
            'ind': 'Indon√©sio',
            'may': 'Malaio',
            'msa': 'Malaio', // ISO 639-2/T
            'tgl': 'Tagalo',
            'bur': 'Birman√™s',
            'mya': 'Birman√™s', // ISO 639-2/T
            'khm': 'Khmer',
            'lao': 'Laosiano',

            // Leste Asi√°tico
            'mon': 'Mongol',

            // √Åfrica
            'swa': 'Sua√≠li',
            'amh': 'Am√°rico',
            'hau': 'Hau√ß√°',
            'yor': 'Iorub√°',
            'ibo': 'Igbo',
            'zul': 'Zulu',
            'xho': 'Xhosa',
            'afr': 'Afric√¢nder',
            'som': 'Somali',

            // L√≠nguas constru√≠das
            'epo': 'Esperanto',

            // Outros
            'cat': 'Catal√£o',
            'baq': 'Basco',
            'eus': 'Basco', // ISO 639-2/T
            'glg': 'Galego',

            // Desconhecido
            'und': 'Desconhecido'
        };

        let baseName = names[code] || code.toUpperCase();

        // Adicionar variante ao nome
        if (variant) {
            const variantNames = {
                'BR': '(Brasil)',
                'PT': '(Portugal)',
                'US': '(EUA)',
                'GB': '(Reino Unido)',
                'LATAM': '(Latam)',
                'ES': '(Espanha)',
                'CA': '(Canad√°)',
                'TRAD': '(Tradicional)',
                'SIMP': '(Simplificado)'
            };
            baseName += ' ' + (variantNames[variant] || '');
        }

        return baseName;
    }

    selectAllTracks() {
        this.tracks.forEach(track => {
            this.selectedTracks.add(track.id);
        });

        document.querySelectorAll('.track-checkbox').forEach(cb => {
            cb.checked = true;
        });

        this.updateSelectionCount();
    }

    deselectAllTracks() {
        this.selectedTracks.clear();

        document.querySelectorAll('.track-checkbox').forEach(cb => {
            cb.checked = false;
        });

        this.updateSelectionCount();
    }

    updateSelectionCount() {
        const count = this.selectedTracks.size;
        const total = this.tracks.length;

        if (this.extractBtn) {
            this.extractBtn.textContent = `Extrair ${count} Track${count !== 1 ? 's' : ''}`;
            this.extractBtn.disabled = count === 0;
        }

        console.log(`üìä Selecionadas: ${count}/${total} tracks`);
    }

    async extractSelectedTracks() {
        if (this.selectedTracks.size === 0) {
            alert('Por favor selecione pelo menos uma track!');
            return;
        }

        console.log('üöÄ Extraindo tracks selecionadas:', Array.from(this.selectedTracks));

        this.extractProgress.classList.remove('hidden');

        try {
            // Criar FormData
            const formData = new FormData();
            formData.append('mkv_file', this.currentMkvFile);
            formData.append('track_ids', JSON.stringify(Array.from(this.selectedTracks)));

            // Chamar backend para extrair
            const response = await fetch('http://localhost:8080/api/mkv/extract', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error(`Erro HTTP: ${response.status}`);
            }

            const result = await response.json();
            console.log('‚úÖ Extra√ß√£o conclu√≠da:', result);

            this.showExtractedFiles(result.extracted_files);

            // Perguntar sobre tradu√ß√£o
            this.promptTranslation(result.extracted_files);

        } catch (error) {
            console.error('‚ùå Erro ao extrair tracks:', error);
            alert(`Erro na extra√ß√£o: ${error.message}`);
        } finally {
            this.extractProgress.classList.add('hidden');
        }
    }

    showExtractedFiles(files) {
        this.extractedList.innerHTML = '';

        files.forEach(file => {
            const item = document.createElement('div');
            item.className = 'extracted-file-item';
            item.innerHTML = `
                <span class="file-icon">üìÑ</span>
                <span class="file-path">${file.path}</span>
                <span class="file-size">${this.formatFileSize(file.size)}</span>
            `;
            this.extractedList.appendChild(item);
        });
    }

    formatFileSize(bytes) {
        if (bytes < 1024) return `${bytes} B`;
        if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
        return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    }

    async promptTranslation(extractedFiles) {
        // Criar modal de confirma√ß√£o
        const proceed = confirm(
            `‚úÖ ${extractedFiles.length} ficheiro(s) extra√≠do(s) com sucesso!\n\n` +
            `Deseja traduzir estas legendas agora?`
        );

        if (proceed) {
            console.log('üîÑ Iniciando tradu√ß√£o...');

            // Carregar primeira legenda na interface principal
            if (extractedFiles.length > 0) {
                const firstFile = extractedFiles[0];

                // Ler o ficheiro extra√≠do
                try {
                    const response = await fetch(`http://localhost:8080/api/file?path=${encodeURIComponent(firstFile.path)}`);
                    const content = await response.text();

                    // Criar um objeto File simulado
                    const blob = new Blob([content], { type: 'text/plain' });
                    const originalMkvName = this.currentMkvFile ? this.currentMkvFile.name.replace('.mkv', '') : 'subtitle';
                    const file = new File([blob], `${originalMkvName}_EN.srt`, { type: 'text/plain' });

                    // Trigger evento para carregar no tradutor com o ficheiro
                    const event = new CustomEvent('loadSubtitleFile', {
                        detail: {
                            file: file,
                            content: content
                        }
                    });
                    document.dispatchEvent(event);

                    // Fechar painel de extra√ß√£o e mostrar √°rea de upload
                    this.tracksCard.classList.add('hidden');
                    const mkvSection = document.getElementById('mkvExtractorSection');
                    if (mkvSection) {
                        mkvSection.classList.add('hidden');
                    }
                    const uploadArea = document.querySelector('.upload-area');
                    if (uploadArea) {
                        uploadArea.classList.remove('hidden');
                    }

                } catch (error) {
                    console.error('‚ùå Erro ao carregar ficheiro:', error);
                    alert('Erro ao carregar ficheiro para tradu√ß√£o. Tente fazer download manual.');
                }
            }
        } else {
            console.log('üíæ Preparando download das legendas...');

            // Oferecer download dos ficheiros
            this.offerDownload(extractedFiles);
        }
    }

    offerDownload(extractedFiles) {
        // Criar interface de download
        const downloadSection = document.createElement('div');
        downloadSection.className = 'download-section';
        downloadSection.style.cssText = `
            margin-top: 20px;
            padding: 20px;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 10px;
        `;

        const originalMkvName = this.currentMkvFile ? this.currentMkvFile.name.replace('.mkv', '') : 'subtitle';

        downloadSection.innerHTML = `
            <h4 style="margin-top: 0; color: #10b981;">üíæ Guardar Legendas</h4>
            <p style="margin-bottom: 15px;">Escolha onde guardar as legendas extra√≠das:</p>
        `;

        extractedFiles.forEach((file, index) => {
            const downloadBtn = document.createElement('button');
            downloadBtn.className = 'btn btn-secondary';
            downloadBtn.style.cssText = 'margin: 5px; width: 100%;';

            const suggestedName = index === 0
                ? `${originalMkvName}_EN.srt`
                : `${originalMkvName}_EN_track${file.track_id || index+1}.srt`;

            downloadBtn.innerHTML = `üì• Guardar como: ${suggestedName}`;
            downloadBtn.onclick = () => this.downloadFile(file.path, suggestedName);

            downloadSection.appendChild(downloadBtn);
        });

        // Adicionar √† lista de ficheiros extra√≠dos
        this.extractedList.appendChild(downloadSection);
    }

    async downloadFile(filePath, suggestedName) {
        try {
            // Buscar conte√∫do do ficheiro
            const response = await fetch(`http://localhost:8080/api/file?path=${encodeURIComponent(filePath)}`);
            const content = await response.text();

            // Criar blob e download
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = suggestedName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log(`‚úÖ Download iniciado: ${suggestedName}`);
        } catch (error) {
            console.error('‚ùå Erro no download:', error);
            alert('Erro ao fazer download do ficheiro.');
        }
    }
}

// Inst√¢ncia global
let mkvExtractorUI = null;

function initMKVExtractor() {
    if (!mkvExtractorUI) {
        mkvExtractorUI = new MKVExtractorUI();
    }
    return mkvExtractorUI;
}
